import numpy as np
import os
import mlx as ml
import cPickle as pickle
import sys
import re
import networkx as nx
from pprint import pprint
from collections import deque
from copy import deepcopy
import random
import argparse

parser = argparse.ArgumentParser()
parser.add_argument('seq_path', type=str, help="Path to sequence to perturb")
parser.add_argument('perturbation_path', type=str, help="Path to pickle file generated by perturb_sequence.py")
parser.add_argument('out_path', type=str, help="Filepath to store results in")
parser.add_argument('--num_samples', type=int, default=500, help="Number of samples to generate")
results = parser.parse_args()

seq_path = results.seq_path
perturbation_path = results.perturbation_path
out_path = results.out_path
num_samples = results.num_samples

with open(seq_path, 'r') as fh:
    sequence = fh.read().strip().split(',')

with open(perturbation_path, 'r') as fh:
    primary_perturbations, secondary_perturbations = pickle.load(fh)

def update_sequence(sequence, perturbation_list):
    sequence = list(sequence)
    perturbation_dicts = [x[0] for x in perturbation_list]
    probabilities = [x[1] for x in perturbation_list]

    selected_perturbation = np.random.choice(perturbation_dicts, 1, probabilities)[0]
    for index in selected_perturbation:
        sequence[index] = selected_perturbation[index]
    return sequence

with open(out_path, 'w') as fh:
    for i in range(num_samples):
        new_sequence = update_sequence(sequence, primary_perturbations)
        for perturbation in secondary_perturbations:
            new_sequence = update_sequence(new_sequence, perturbation)
        fh.write(','.join(new_sequence))
        fh.write('\n')
